// src/modules/statement_parser.rs
// Handles parsing of statements

use crate::modules::tokenizer::Token;
use crate::modules::ast::{Statement, ASTValue, Type, BinaryOp};
use crate::modules::expression_parser::ExpressionParser;

pub struct StatementParser<'a> {
    tokens: &'a [Token],
    pos: usize,
}

impl<'a> StatementParser<'a> {
    pub fn new(tokens: &'a [Token], start_pos: usize) -> Self {
        Self { tokens, pos: start_pos }
    }

    pub fn current_pos(&self) -> usize {
        self.pos
    }

    fn peek(&self) -> Option<&Token> {
        self.tokens.get(self.pos)
    }

    fn peek_ahead(&self, n: usize) -> Option<&Token> {
        self.tokens.get(self.pos + n)
    }

    fn advance(&mut self) -> Option<&Token> {
        let token = self.tokens.get(self.pos);
        if token.is_some() {
            self.pos += 1;
        }
        token
    }

    fn expect(&mut self, expected: Token) -> Result<(), String> {
        match self.peek() {
            Some(token) if token == &expected => {
                self.advance();
                Ok(())
            }
            Some(token) => Err(format!("Expected {:?}, found {:?}", expected, token)),
            None => Err(format!("Expected {:?}, found end of input", expected)),
        }
    }

    pub fn parse_statement(&mut self) -> Result<Option<Statement>, String> {
        match self.peek() {
            Some(Token::Let) | Some(Token::Const) => self.parse_var_decl(),
            Some(Token::If) => self.parse_if_statement(),
            Some(Token::While) => self.parse_while_statement(),
            Some(Token::For) => self.parse_for_statement(),
            Some(Token::ForEach) => self.parse_foreach_statement(),
            Some(Token::Match) => self.parse_match_statement(),
            Some(Token::Return) => self.parse_return_statement(),
            Some(Token::Break) => {
                self.advance();
                self.expect(Token::Semicolon)?;
                Ok(Some(Statement::Break))
            }
            Some(Token::Continue) => {
                self.advance();
                self.expect(Token::Semicolon)?;
                Ok(Some(Statement::Continue))
            }
            Some(Token::LBrace) => self.parse_block(),
            Some(Token::Semicolon) => {
                self.advance();
                Ok(None) // Empty statement
            }
            _ => self.parse_expression_or_assignment(),
        }
    }

    fn parse_type(&mut self) -> Result<Type, String> {
        match self.peek() {
            Some(Token::I32Type) => {
                self.advance();
                Ok(Type::I32)
            }
            Some(Token::I64Type) => {
                self.advance();
                Ok(Type::I64)
            }
            Some(Token::F32Type) => {
                self.advance();
                Ok(Type::F32)
            }
            Some(Token::F64Type) => {
                self.advance();
                Ok(Type::F64)
            }
            Some(Token::StringType) => {
                self.advance();
                Ok(Type::String)
            }
            Some(Token::BoolType) => {
                self.advance();
                Ok(Type::Bool)
            }
            Some(Token::Void) => {
                self.advance();
                Ok(Type::Void)
            }
            Some(Token::VarType) => {
                self.advance();
                Ok(Type::Auto)
            }
            Some(Token::Ident(name)) => {
                let type_name = name.clone();
                self.advance();
                
                // Check for array type: TypeName[]
                if matches!(self.peek(), Some(Token::LBracket)) {
                    self.advance();
                    self.expect(Token::RBracket)?;
                    Ok(Type::Array(Box::new(Type::Custom(type_name))))
                } else {
                    Ok(Type::Custom(type_name))
                }
            }
            Some(token) => Err(format!("Expected type, found {:?}", token)),
            None => Err("Expected type, found end of input".to_string()),
        }
    }

    fn parse_var_decl(&mut self) -> Result<Option<Statement>, String> {
        let is_const = matches!(self.peek(), Some(Token::Const));
        self.advance(); // Skip 'let' or 'const'
        
        let is_mutable = if matches!(self.peek(), Some(Token::Mut)) {
            self.advance();
            true
        } else {
            false
        };

        // Check if we have a type annotation
        let (var_type, name) = if self.is_type_token(self.peek()) {
            let ty = self.parse_type()?;
            
            if let Some(Token::Ident(n)) = self.peek() {
                let name = n.clone();
                self.advance();
                (ty, name)
            } else {
                return Err("Expected variable name after type".to_string());
            }
        } else {
            // Type inference
            if let Some(Token::Ident(n)) = self.peek() {
                let name = n.clone();
                self.advance();
                (Type::Auto, name)
            } else {
                return Err("Expected variable name".to_string());
            }
        };

        let value = if matches!(self.peek(), Some(Token::Eq)) {
            self.advance();
            let mut expr_parser = ExpressionParser::new(self.tokens, self.pos);
            let val = expr_parser.parse_expression()?;
            self.pos = expr_parser.current_pos();
            Some(val)
        } else {
            None
        };

        self.expect(Token::Semicolon)?;

        Ok(Some(Statement::VarDecl {
            name,
            var_type,
            value,
            is_mutable: !is_const && is_mutable,
        }))
    }

    fn is_type_token(&self, token: Option<&Token>) -> bool {
        matches!(
            token,
            Some(Token::I32Type)
                | Some(Token::I64Type)
                | Some(Token::F32Type)
                | Some(Token::F64Type)
                | Some(Token::StringType)
                | Some(Token::BoolType)
                | Some(Token::Void)
                | Some(Token::VarType)
        )
    }

    fn parse_if_statement(&mut self) -> Result<Option<Statement>, String> {
        self.advance(); // Skip 'if'

        // Parse condition (with optional parentheses)
        let has_paren = matches!(self.peek(), Some(Token::LParen));
        if has_paren {
            self.advance();
        }

        let mut expr_parser = ExpressionParser::new(self.tokens, self.pos);
        let condition = expr_parser.parse_expression()?;
        self.pos = expr_parser.current_pos();

        if has_paren {
            self.expect(Token::RParen)?;
        }

        let then_body = self.parse_block_or_statement()?;

        // Parse elif branches
        let mut elif_branches = Vec::new();
        while matches!(self.peek(), Some(Token::Elif)) {
            self.advance();

            let has_paren = matches!(self.peek(), Some(Token::LParen));
            if has_paren {
                self.advance();
            }

            let mut expr_parser = ExpressionParser::new(self.tokens, self.pos);
            let elif_condition = expr_parser.parse_expression()?;
            self.pos = expr_parser.current_pos();

            if has_paren {
                self.expect(Token::RParen)?;
            }

            let elif_body = self.parse_block_or_statement()?;
            elif_branches.push((elif_condition, elif_body));
        }

        // Parse else
        let else_body = if matches!(self.peek(), Some(Token::Else)) {
            self.advance();
            Some(self.parse_block_or_statement()?)
        } else {
            None
        };

        Ok(Some(Statement::If {
            condition,
            then_body,
            elif_branches,
            else_body,
        }))
    }

    fn parse_while_statement(&mut self) -> Result<Option<Statement>, String> {
        self.advance(); // Skip 'while'

        let has_paren = matches!(self.peek(), Some(Token::LParen));
        if has_paren {
            self.advance();
        }

        let mut expr_parser = ExpressionParser::new(self.tokens, self.pos);
        let condition = expr_parser.parse_expression()?;
        self.pos = expr_parser.current_pos();

        if has_paren {
            self.expect(Token::RParen)?;
        }

        let body = self.parse_block_or_statement()?;

        Ok(Some(Statement::While { condition, body }))
    }

    fn parse_for_statement(&mut self) -> Result<Option<Statement>, String> {
        self.advance(); // Skip 'for'
        self.expect(Token::LParen)?;

        // Parse init
        let init = if matches!(self.peek(), Some(Token::Semicolon)) {
            self.advance();
            None
        } else {
            let stmt = self.parse_statement()?;
            stmt.map(Box::new)
        };

        // Parse condition
        let condition = if matches!(self.peek(), Some(Token::Semicolon)) {
            self.advance();
            None
        } else {
            let mut expr_parser = ExpressionParser::new(self.tokens, self.pos);
            let cond = expr_parser.parse_expression()?;
            self.pos = expr_parser.current_pos();
            self.expect(Token::Semicolon)?;
            Some(cond)
        };

        // Parse increment
        let increment = if matches!(self.peek(), Some(Token::RParen)) {
            None
        } else {
            let stmt = self.parse_expression_or_assignment()?;
            stmt.map(Box::new)
        };

        self.expect(Token::RParen)?;

        let body = self.parse_block_or_statement()?;

        Ok(Some(Statement::For {
            init,
            condition,
            increment,
            body,
        }))
    }

    fn parse_foreach_statement(&mut self) -> Result<Option<Statement>, String> {
        self.advance(); // Skip 'foreach'
        self.expect(Token::LParen)?;

        let item_type = self.parse_type()?;
        
        if let Some(Token::Ident(item)) = self.peek() {
            let item = item.clone();
            self.advance();
            
            self.expect(Token::In)?;
            
            let mut expr_parser = ExpressionParser::new(self.tokens, self.pos);
            let collection = expr_parser.parse_expression()?;
            self.pos = expr_parser.current_pos();
            
            self.expect(Token::RParen)?;
            
            let body = self.parse_block_or_statement()?;
            
            Ok(Some(Statement::ForEach {
                item,
                item_type,
                collection,
                body,
            }))
        } else {
            Err("Expected item name in foreach".to_string())
        }
    }

    fn parse_match_statement(&mut self) -> Result<Option<Statement>, String> {
        self.advance(); // Skip 'match'
        
        let mut expr_parser = ExpressionParser::new(self.tokens, self.pos);
        let value = expr_parser.parse_expression()?;
        self.pos = expr_parser.current_pos();
        
        self.expect(Token::LBrace)?;
        
        let mut arms = Vec::new();
        
        while !matches!(self.peek(), Some(Token::RBrace)) {
            // Parse pattern (simplified - just literals or wildcard)
            let pattern = match self.peek() {
                Some(Token::Integer(n)) => {
                    let val = crate::modules::ast::Pattern::Literal(ASTValue::Int(*n));
                    self.advance();
                    val
                }
                Some(Token::String(s)) => {
                    let val = crate::modules::ast::Pattern::Literal(ASTValue::Str(s.clone()));
                    self.advance();
                    val
                }
                Some(Token::Ident(name)) if name == "_" => {
                    self.advance();
                    crate::modules::ast::Pattern::Wildcard
                }
                Some(Token::Ident(name)) => {
                    let val = crate::modules::ast::Pattern::Identifier(name.clone());
                    self.advance();
                    val
                }
                _ => return Err("Expected pattern in match arm".to_string()),
            };
            
            self.expect(Token::FatArrow)?;
            
            let body = if matches!(self.peek(), Some(Token::LBrace)) {
                self.parse_block_statements()?
            } else {
                let stmt = self.parse_statement()?;
                if let Some(s) = stmt {
                    vec![s]
                } else {
                    Vec::new()
                }
            };
            
            arms.push(crate::modules::ast::MatchArm { pattern, body });
            
            if matches!(self.peek(), Some(Token::Comma)) {
                self.advance();
            }
        }
        
        self.expect(Token::RBrace)?;
        
        Ok(Some(Statement::Match { value, arms }))
    }

    fn parse_return_statement(&mut self) -> Result<Option<Statement>, String> {
        self.advance(); // Skip 'return'

        let value = if matches!(self.peek(), Some(Token::Semicolon)) {
            None
        } else {
            let mut expr_parser = ExpressionParser::new(self.tokens, self.pos);
            let val = expr_parser.parse_expression()?;
            self.pos = expr_parser.current_pos();
            Some(val)
        };

        self.expect(Token::Semicolon)?;
        Ok(Some(Statement::Return(value)))
    }

    fn parse_block(&mut self) -> Result<Option<Statement>, String> {
        let statements = self.parse_block_statements()?;
        Ok(Some(Statement::Block(statements)))
    }

    fn parse_block_statements(&mut self) -> Result<Vec<Statement>, String> {
        self.expect(Token::LBrace)?;
        
        let mut statements = Vec::new();
        
        while !matches!(self.peek(), Some(Token::RBrace)) {
            if let Some(stmt) = self.parse_statement()? {
                statements.push(stmt);
            }
        }
        
        self.expect(Token::RBrace)?;
        Ok(statements)
    }

    fn parse_block_or_statement(&mut self) -> Result<Vec<Statement>, String> {
        if matches!(self.peek(), Some(Token::LBrace)) {
            self.parse_block_statements()
        } else {
            let stmt = self.parse_statement()?;
            Ok(if let Some(s) = stmt { vec![s] } else { Vec::new() })
        }
    }

    fn parse_expression_or_assignment(&mut self) -> Result<Option<Statement>, String> {
        let _start_pos = self.pos;
        
        let mut expr_parser = ExpressionParser::new(self.tokens, self.pos);
        let expr = expr_parser.parse_expression()?;
        self.pos = expr_parser.current_pos();

        // Check for assignment operators
        match self.peek() {
            Some(Token::Eq) => {
                self.advance();
                let mut expr_parser = ExpressionParser::new(self.tokens, self.pos);
                let value = expr_parser.parse_expression()?;
                self.pos = expr_parser.current_pos();
                self.expect(Token::Semicolon)?;
                Ok(Some(Statement::Assignment { target: expr, value }))
            }
            Some(Token::PlusEq) | Some(Token::MinusEq) | Some(Token::StarEq) 
            | Some(Token::SlashEq) | Some(Token::PercentEq) => {
                let op = match self.peek().unwrap() {
                    Token::PlusEq => BinaryOp::Add,
                    Token::MinusEq => BinaryOp::Sub,
                    Token::StarEq => BinaryOp::Mul,
                    Token::SlashEq => BinaryOp::Div,
                    Token::PercentEq => BinaryOp::Mod,
                    _ => unreachable!(),
                };
                self.advance();
                let mut expr_parser = ExpressionParser::new(self.tokens, self.pos);
                let value = expr_parser.parse_expression()?;
                self.pos = expr_parser.current_pos();
                self.expect(Token::Semicolon)?;
                Ok(Some(Statement::CompoundAssignment { target: expr, op, value }))
            }
            _ => {
                self.expect(Token::Semicolon)?;
                Ok(Some(Statement::Expression(expr)))
            }
        }
    }
}
